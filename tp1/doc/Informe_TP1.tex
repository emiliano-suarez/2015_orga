\documentclass[a4paper,10pt]{article}

\usepackage{graphicx}
\usepackage[ansinew]{inputenc}
\usepackage[spanish]{babel}
\usepackage{listings}
\usepackage{color}
\usepackage{framed}
\usepackage{graphicx}
\usepackage{mathtools}
\usepackage{amsmath}
\usepackage{epstopdf}
\usepackage[T1]{fontenc}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{ %
  language=C,                       % the language of the code
  basicstyle=\footnotesize,         % the size of the fonts that are used for the code
  numbers=left,                     % where to put the line-numbers
  numberstyle=\tiny\color{gray},    % the style that is used for the line-numbers
  stepnumber=1,                     % the step between two line-numbers. If it's 1, each line 
                                    % will be numbered
  numbersep=5pt,                    % how far the line-numbers are from the code
  backgroundcolor=\color{white},    % choose the background color. You must add \usepackage{color}
  showspaces=false,                 % show spaces adding particular underscores
  showstringspaces=false,           % underline spaces within strings
  showtabs=false,                   % show tabs within strings adding particular underscores
  frame=single,                     % adds a frame around the code
  rulecolor=\color{black},          % if not set, the frame-color may be changed on line-breaks within not-black text (e.g. commens (green here))
  tabsize=2,                        % sets default tabsize to 2 spaces
  captionpos=b,                     % sets the caption-position to bottom
  breaklines=true,                  % sets automatic line breaking
  breakatwhitespace=false,          % sets if automatic breaks should only happen at whitespace
  title=\lstname,                   % show the filename of files included with \lstinputlisting;
                                    % also try caption instead of title
  keywordstyle=\color{blue},        % keyword style
  commentstyle=\color{dkgreen},     % comment style
  stringstyle=\color{mauve},        % string literal style
  escapeinside={\%*}{*)},           % if you want to add LaTeX within your code
  morekeywords={*,...},             % if you want to add more keywords to the set
  rulesepcolor=\color{blue}
}

\title{     \textbf{Trabajo Práctico 1: \\ Conjunto de instrucciones MIPS}}

\author{
            Jimenez, Ruben, \textit{Padrón Nro. 92.402}                            \\
            \texttt{ rbnm.jimenez@gmail.com }                                   \\[2.5ex]
            Reyero, Felix, \textit{Padrón Nro. 92.979}                             \\
            \texttt{ felixcarp@gmail.com }                                    \\[2.5ex]
            Suárez, Emiliano, \textit{Padrón Nro. 78.372}                             \\
            \texttt{ emilianosuarez@gmail.com }                                    \\[2.5ex]
    Primera Entrega: \textit{30/04/2015}                                            \\[1.5ex]
            \normalsize{1er. Cuatrimestre de 2015}                                  \\
            \normalsize{66.20 Organización de Computadoras  $-$ Práctica Jueves}    \\
            \normalsize{Facultad de Ingeniería, Universidad de Buenos Aires}        \\
       }
\date{}

\begin{document}

\maketitle
\thispagestyle{empty}   % quita el número en la primer página

\newpage
\begin{abstract}
Se implementó una versión simplificada del programa \textbf{sha1} de UNIX. Para nuestra implementación.
\end{abstract}

\section{Introducción}

Este Trabajo Práctico pretende familiarizarse con la programación en assembly y el concepto de ABI.

Para ello, implementaremos el algoritmo \textbf{sha1} de UNIX en código \textsl{Assembly}, mientras que la interpretación de argumentos del programa y la lectura de archivos será realizada en lenguaje \textsl{C}.

Además, se utilizará \textsl{GXemul} para simular una máquina \textsl{MIPS} corriendo una versión reciente del sistema operativo \textsl{NetBSD}.

El programa implementado, muestra por \textsl{stdout} un checksum generado a partir del contenido de los archivos archivos pasados por parámetro. En caso de no especificarse algún archivo, se mostrarán un checksum a partir de lo ingresado por \textsl{stdin}.

\newpage
\section{Diseño e Implementación}

Se implementó un programa que realiza la lectura a través del stdin o a través de archivos que se reciben por parámetro.

El comando acepta 2 parámetros para mostrar la Ayuda y la Versión del programa:
\begin{verbatim}
$ ./sha -h
$ ./sha --help
\end{verbatim}
Para desplegar la ayuda del comando.
Y los siguientes comandos para mostrar la versión:
\begin{verbatim}
$ ./sha -V
$ ./sha --version
\end{verbatim}

Inicialmente el programa revisa la cadena de parametros ingresada y determina si el checksum debe generarse a partir de lo ingresado por \textsl{stdin} o a través del contenido del (o los) archivo(s).

Para este última opción, se procesan los archivo de uno por vez, y para cada uno de ellos se genera el checksum a partir de sus datos.

\subsection{Compilación}
Para compilar el programa se debe abrir una terminal en la carpeta donde están alojados los archivos fuentes (\textsl{src/}) y se ejecuta el siguiente comando:
\begin{verbatim}
../src$ gcc -g -O0 -Wall main.c algoritmo.S trozo.S relleno.S -o sha
\end{verbatim}
Para generar el ejecutable \textsl{sha}.

\subsection{Arquitectura}

En una primera versión se trabajo con una función \textsl{sha} íntegramente desarrollada en \textsl{Assembly}, con un stack mas grande. Pero tuvimos problemas con el \textsl{malloc} al intentar reservar memoria para los bloques a procesar por el algoritmo. Como una alternativa, probamos utilizar la función \textsl{malloc} de \textsl{C} desde \textsl{Assembly}, realizando \textsl{syscall} e incluso, utilizando la versión en \textsl{Assembly} de \textsl{mymalloc.S} que se encuentra en el grupo.

Con ninguna de estas opciones lograr que la función \textsl{sha} funcionara correctamente, por lo que decidimos modularizarla de la siguiente manera.

\begin{description}
  \item[main.c] \hfill \\
  Cuerpo principal del programa, donde se realiza la lectura de los parámetros de los archivos.
  \item[relleno.S] \hfill \\
  Donde se encuentra la implementación en \textsl{Assembly} de la función \textsl{calcularRelleno}.
  \item[trozo.S] \hfill \\
  Donde se encuentra la implementación en \textsl{Assembly} de la función \textsl{cargarTrozos}.
  \item[algoritmo.S] \hfill \\
  Donde se encuentra la implementación en \textsl{Assembly} de la función \textsl{algoritmoSha1}.\hfill \\
\end{description}

Las funciones \textsl{calcularRelleno}, \textsl{cargarTrozos} y \textsl{algoritmoSha1}, son llamadas desde la función \textsl{sha1} de \textsl{main.c}.

Los stacks de cada una de ellas que pueden observase a continuación:

\begin{center}
    \begin{tabular}{ | p{3cm} | p{3cm}  | }
    \hline
        \multicolumn{2}{|c|}{calcularRelleno} \\ \hline
        Dir Mem & Valor \\ \hline
        44 &  \\ \hline
        40 & ra \\ \hline
        36 & fp \\ \hline
        32 & gp \\ \hline
        28 & longOrig \\ \hline
        24 & longOrig \\ \hline
        20 & longRelleno \\ \hline
        16 & longRelleno \\ \hline
        12 & a3 \\ \hline
        8 & a2 \\ \hline
        4 & a1 \\ \hline
        0 & a0 \\ \hline
        \hline
    \end{tabular}
\end{center}

\begin{center}
    \begin{tabular}{ | p{3cm} | p{3cm}  | }
    \hline
        \multicolumn{2}{|c|}{cargarTrozos} \\ \hline
        Dir Mem & Valor \\ \hline
        36 &  \\ \hline
        32 & ra \\ \hline
        28 & fp \\ \hline
        24 & gp \\ \hline
        20 & mascara \\ \hline
        16 & i \\ \hline
        12 & a3 \\ \hline
        8 & a2 \\ \hline
        4 & a1 \\ \hline
        0 & a0 \\ \hline
        \hline
    \end{tabular}
\end{center}

\begin{center}
    \begin{tabular}{ | p{3cm} | p{3cm}  | }
    \hline
        \multicolumn{2}{|c|}{algoritmoSha1} \\ \hline
        Dir Mem & Valor \\ \hline
        44 &  \\ \hline
        40 & ra \\ \hline
        36 & fp \\ \hline
        32 & gp \\ \hline
        28 &  \\ \hline
        24 & temp \\ \hline
        20 & k \\ \hline
        16 & i \\ \hline
        12 & a3 \\ \hline
        8 & a2 \\ \hline
        4 & a1 \\ \hline
        0 & a0 \\ \hline
        \hline
    \end{tabular}
\end{center}

\begin{center}
    \begin{tabular}{ | p{3cm} | p{3cm}  | }
    \hline
        Registro & Valor \\ \hline
        s0 & bloques \\ \hline
        s1 & trozos \\ \hline
        s2 & a \\ \hline
        s3 & b \\ \hline
        s4 & c \\ \hline
        s5 & d \\ \hline
        s6 & e \\ \hline
        s7 & f \\ \hline
    \end{tabular}
\end{center}

\section{Casos de Prueba}
Algunos de los casos de pruebas realizados, pueden observarse a continuación:

\begin{verbatim}
root@:/home/gxemul/tprub/div# sha1 hola
SHA1 (hola) = ef443fee4da6bfb41651930de7ad99f29ed9f079
root@:/home/gxemul/tprub/div# ./sha hola
ef443fee4da6bfb41651930de7ad99f29ed9f079

root@:/home/gxemul/tprub/div# sha1 vacio
SHA1 (vacio) = da39a3ee5e6b4b0d3255bfef95601890afd80709
root@:/home/gxemul/tprub/div# ./sha vacio
da39a3ee5e6b4b0d3255bfef95601890afd80709

root@:/home/gxemul/tprub/div# sha1 prueba-dog
SHA1 (prueba-dog) = 2fd4e1c67a2d28fced849ee1bb76e7391b93eb12
root@:/home/gxemul/tprub/div# ./sha prueba-dog
2fd4e1c67a2d28fced849ee1bb76e7391b93eb12

root@:/home/gxemul/tprub/div# sha1 prueba-cog
SHA1 (prueba-cog) = de9f2c7fd25e1b3afad3e85a0bd17d9b100db4b3
root@:/home/gxemul/tprub/div# ./sha prueba-cog
de9f2c7fd25e1b3afad3e85a0bd17d9b100db4b3
\end{verbatim}

\newpage
\section{Conclusiones}

El presente trabajo permitió la familiarización con las herramientas de compilación de código C y código assembly en un entorno que emula la arquitectura MIPS 32, asegurando la portabilidad del programa.

Además nos permitió conocer en detalle como se comporta el stack de una función en la programación en \textsl{Assembly}.
Para esto último, fue de gran ayuda conocer previamente la implementación de las funciones en lenguage C, para luego hacer la ``traducción'' a \textsl{Assembly} teniendo en cuenta la cantidad de argumentos, variables locales, tamaño de los datos, etc.

\newpage
\section{Apéndice}
\subsection{Código Fuente: main.c}
\lstinputlisting{../src/main.c}

\subsection{Código Fuente: relleno.S}
\lstinputlisting{../src/relleno.S}

\subsection{Código Fuente: trozo.S}
\lstinputlisting{../src/trozo.S}

\subsection{Código Fuente: algoritmo.S}
\lstinputlisting{../src/algoritmo.S}
\end{document}
